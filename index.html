<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ultimate Screen Recorder Pro+</title>
<link rel="icon" href="icon.png" type="image/png">
<style>
    body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #00ffff, #8e24aa, #ff69b4);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        color: white;
        margin: 0;
        padding-top: 40px;
    }

    h1 {
        margin-bottom: 20px;
        text-shadow: 1px 1px 5px #000;
    }

    .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        justify-content: center;
    }

    select, button, label {
        padding: 10px 16px;
        border: none;
        border-radius: 10px;
        background-color: rgba(0,0,0,0.5);
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.3s;
    }

    select:hover, button:hover, label:hover {
        background-color: rgba(0,0,0,0.7);
    }

    #timer {
        font-size: 24px;
        font-weight: bold;
        text-shadow: 1px 1px 3px #000;
        margin-top: 10px;
    }

    video {
        margin-top: 20px;
        max-width: 80%;
        border: 2px solid white;
        border-radius: 10px;
    }

    #downloadBtn {
        padding: 10px 20px;
        margin-top: 10px;
        border: none;
        border-radius: 10px;
        background-color: rgba(0,0,0,0.5);
        color: white;
        font-size: 16px;
        cursor: pointer;
        transition: background 0.3s;
    }

    #downloadBtn:hover {
        background-color: rgba(0,0,0,0.7);
    }

    /* Floating Toolbox */
    #floatingToolbox {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        padding: 8px;
        border-radius: 12px;
        display: flex;
        gap: 8px;
        z-index: 9999;
        cursor: move;
        user-select: none;
    }

    #floatingToolbox button {
        background: rgba(255,255,255,0.1);
        padding: 5px 10px;
        border-radius: 6px;
        border: none;
        color: white;
        font-size: 13px;
        cursor: pointer;
    }

    #floatingToolbox button:hover {
        background: rgba(255,255,255,0.3);
    }

    #micToggle {
        background: rgba(255,255,255,0.1);
    }
</style>
</head>
<body>
<h1>Ultimate Screen Recorder Pro+</h1>

<div class="controls">
    <select id="resolution">
        <option value="1280x720">720p</option>
        <option value="1920x1080" selected>1080p</option>
        <option value="2560x1440">1440p</option>
        <option value="3840x2160">4K</option>
    </select>

    <select id="fps">
        <option value="30">30 FPS</option>
        <option value="60" selected>60 FPS</option>
    </select>

    <label>
        <input type="checkbox" id="micCheckbox">
        Mic On
    </label>

    <button id="start">Start Recording</button>
</div>

<div id="timer">00:00:00</div>
<video id="preview" controls hidden></video>
<button id="downloadBtn" hidden>Download Video</button>

<!-- Floating toolbox -->
<div id="floatingToolbox" hidden>
    <button id="pauseBtn">‚è∏ Pause</button>
    <button id="resumeBtn" disabled>‚ñ∂ Resume</button>
    <button id="stopBtn">‚èπ Stop</button>
    <button id="micToggle">üé§ Mic</button>
</div>

<script>
let mediaRecorder;
let recordedChunks = [];
let timerInterval;
let seconds = 0;
let stream;
let micStream;
let mixedStream;
let micEnabled = false;

const toolbox = document.getElementById('floatingToolbox');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const micToggle = document.getElementById('micToggle');

function updateTimer() {
    seconds++;
    const h = String(Math.floor(seconds / 3600)).padStart(2,'0');
    const m = String(Math.floor((seconds % 3600)/60)).padStart(2,'0');
    const s = String(seconds % 60).padStart(2,'0');
    document.getElementById('timer').textContent = `${h}:${m}:${s}`;
}

async function getMicStream() {
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micEnabled = true;
    } catch (err) {
        alert("Mic access denied or unavailable.");
        micEnabled = false;
    }
}

document.getElementById('start').onclick = async () => {
    const [width, height] = document.getElementById('resolution').value.split('x').map(Number);
    const fps = Number(document.getElementById('fps').value);
    const useMic = document.getElementById('micCheckbox').checked;

    try {
        stream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                width: { ideal: width },
                height: { ideal: height },
                frameRate: { ideal: fps, max: fps }
            },
            audio: true
        });

        if (useMic) {
            await getMicStream();
        }

        // Combine screen + mic audio if mic is enabled
        if (micEnabled) {
            const context = new AudioContext();
            const destination = context.createMediaStreamDestination();

            const screenAudio = context.createMediaStreamSource(stream);
            screenAudio.connect(destination);

            const micAudio = context.createMediaStreamSource(micStream);
            micAudio.connect(destination);

            mixedStream = new MediaStream([...stream.getVideoTracks(), ...destination.stream.getAudioTracks()]);
        } else {
            mixedStream = stream;
        }

        mediaRecorder = new MediaRecorder(mixedStream, {
            mimeType: 'video/webm;codecs=vp8,opus',
            videoBitsPerSecond: 8000000
        });

        recordedChunks = [];

        mediaRecorder.ondataavailable = e => {
            if(e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstart = () => {
            timerInterval = setInterval(updateTimer, 1000);
            toolbox.hidden = false;
        };

        mediaRecorder.onstop = () => {
            clearInterval(timerInterval);
            seconds = 0;
            document.getElementById('timer').textContent = '00:00:00';

            stream.getTracks().forEach(t => t.stop());
            if (micStream) micStream.getTracks().forEach(t => t.stop());

            toolbox.hidden = true;
            resumeBtn.disabled = true;
            pauseBtn.disabled = false;

            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const preview = document.getElementById('preview');
            preview.src = url;
            preview.hidden = false;
            preview.play();

            const dl = document.getElementById('downloadBtn');
            dl.hidden = false;
            dl.onclick = () => {
                const a = document.createElement('a');
                a.href = url;
                a.download = 'recording.webm';
                a.click();
            };
        };

        mediaRecorder.start(100);
        document.getElementById('start').disabled = true;

    } catch (err) {
        alert("Recording failed: " + err);
    }
};

// Toolbox buttons
pauseBtn.onclick = () => {
    if (mediaRecorder.state === "recording") {
        mediaRecorder.pause();
        pauseBtn.disabled = true;
        resumeBtn.disabled = false;
    }
};

resumeBtn.onclick = () => {
    if (mediaRecorder.state === "paused") {
        mediaRecorder.resume();
        pauseBtn.disabled = false;
        resumeBtn.disabled = true;
    }
};

stopBtn.onclick = () => {
    if (mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        document.getElementById('start').disabled = false;
    }
};

micToggle.onclick = async () => {
    if (!micEnabled) {
        await getMicStream();
        if (micEnabled) {
            const context = new AudioContext();
            const destination = context.createMediaStreamDestination();
            const screenAudio = context.createMediaStreamSource(stream);
            screenAudio.connect(destination);
            const micAudio = context.createMediaStreamSource(micStream);
            micAudio.connect(destination);
            mixedStream = new MediaStream([...stream.getVideoTracks(), ...destination.stream.getAudioTracks()]);
            alert("Mic turned ON (affects new audio chunks)");
        }
    } else {
        micStream.getTracks().forEach(t => t.stop());
        micEnabled = false;
        alert("Mic turned OFF");
    }
};

// Make toolbox draggable
(function makeDraggable(el) {
    let isDragging = false;
    let offsetX, offsetY;

    el.addEventListener('mousedown', e => {
        isDragging = true;
        offsetX = e.clientX - el.getBoundingClientRect().left;
        offsetY = e.clientY - el.getBoundingClientRect().top;
    });

    document.addEventListener('mousemove', e => {
        if (isDragging) {
            el.style.left = e.clientX - offsetX + 'px';
            el.style.top = e.clientY - offsetY + 'px';
            el.style.right = 'auto';
        }
    });

    document.addEventListener('mouseup', () => isDragging = false);
})(toolbox);
</script>
</body>
</html>
